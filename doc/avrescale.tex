%\documentclass[12pt]{article}
\documentclass[reprint]{revtex4-1}
\usepackage{amsmath}
\usepackage{mathtools}
\usepackage{upgreek}
\usepackage[table,usenames,dvipsnames]{xcolor}
\usepackage{hyperref}

\hypersetup{
  colorlinks,
  linkcolor={red!30!black},
  citecolor={green!20!black},
  urlcolor={blue!80!black}
}


\definecolor{DarkBlue}{RGB}{0,0,64}
\definecolor{DarkBrown}{RGB}{64,20,10}
\definecolor{DarkGreen}{RGB}{0,64,0}
\definecolor{DarkPurple}{RGB}{64,0,42}
\definecolor{LightGray}{gray}{0.85}
% annotation macros
\newcommand{\red}[1]{{\color{red} #1}}
\newcommand{\repl}[2]{{\color{gray} [#1] }{\color{blue} #2}}
\newcommand{\add}[1]{{\color{blue} #1}}
\newcommand{\del}[1]{{\color{gray} [#1]}}
\newcommand{\note}[1]{{\color{DarkGreen}\footnotesize \textsc{Note.} #1}}
\newcommand{\answer}[1]{{\color{DarkBlue}\footnotesize \textsc{Answer.} #1}}
\newcommand{\summary}[1]{{\color{DarkPurple}\footnotesize \textsc{Summary.} #1}}



\begin{document}



\title{Adaptive velocity scaling for an asymptotic
microcanonical ensemble}

\author{Cheng Zhang}
\author{Justin A. Drake}
\author{B. Montgomery Pettitt}
\email{bmpettitt@utmb.edu}
\affiliation{
Sealy Center for Structural Biology and Molecular Biophysics,
The University of Texas Medical Branch,
Galveston, Texas 77555-0304, USA}

%\date{\vspace{-7ex}}
\begin{abstract}
  We present a modification of the commonly-used
  temperature control scheme: velocity scaling.
  %
  The usual velocity scaling scheme produces a perturbation to
  the microcanonical ($NVE$) ensemble
  as the regular scaling operations cause the total energy to fluctuate continually.
  %
  Inspired by the $1/t$ prescription for improving the Wang-Landau algorithm,
  we reduce
  the magnitude of velocity scaling
  by a factor of the number of steps, $t$.
  %
  In this way,
  the fluctuation of total energy becomes negligible at long times,
  and the simulation ensemble becomes effectively
  a microcanonical one.
  %
  Further, we will show that the $1/t$ reduction factor
  allows the microcanonical temperature to tend to the target value
  at an optimal rate.
\end{abstract}

\maketitle



Velocity scaling is a temperature control scheme
for molecular dynamics (MD) simulations.
%
It is usually implemented as
regular velocity scaling operations
that correct the average
kinetic energy of the past few steps, $\bar K$,
to the expected value\cite{frenkel, haile},
%
\begin{equation}
  K^* = \frac{1}{2} N_f \, k_B \, T^*
  ,
  \label{eq:K_canon}
\end{equation}
%
where $N_f$, $k_B$, and $T^*$ are the number of degrees of freedom,
the Boltzmann constant, and the target temperature, respectively.
%
In order words,
the velocity is scaled by a factor of
$\sqrt{ K^* / \bar K }$
in each scaling operation.
%
We refer to this version as the regular velocity scaling below.
%
Velocity scaling has some variants,
among which
the Berendsen thermostat\cite{berendsen1984}
is a notable example.
%
There,
the kinetic energy is changed in each scaling operation
by
%
\begin{equation}
  \delta E = \frac{ K^* - \bar K } { \tau },
  \label{eq:Berendsen}
\end{equation}
%
with $\tau^{-1}$ being the rate of damping.

The above schemes, albeit effective,
do not result in exact sampling for the microcanonical ($NVE$) ensemble\cite{hermansson1988},
because they cause the total energy to fluctuate continually.
%
Thus, they are often regarded as expedient protocols
suitable only for parameter tuning in preliminary MD runs.
%but not for rigorous MD simulations in the microcanonical ensemble.
%
Nor are these schemes exact for the canonical ($NVT$) ensemble,
in which the total energy is intrinsically fluctuating.
%
Fortunately, there are several ingenious ways
of modifying the energy fluctuation caused by velocity scaling
to emulate the effect of a heat-bath,
resulting in exact thermostat algorithms for the $NVT$ ensemble,
e.g., the Nos\'e-Hoover\cite{nose1984, nose1984mp, hoover1985, martyna1992}
and Langevin-style velocity rescaling\cite{bussi2007} thermostats.
%
There,
the velocity scaling operation is carefully
controlled to make
the resulting fluctuation of the total energy
compatible with the underlying canonical distribution.


The existence of exact thermostat algorithms for the $NVT$ ensemble
suggests the possibility of designing
precise temperature controls also
for the $NVE$ ensemble.
%
However, we immediately face a dilemma:
%
as the microcanonical temperature is a function of the total energy, $E$,
one must somehow change the total energy to control the temperature;
%
but doing so too often affects the conservation of the total energy,
and hence the accuracy of the simulation\cite{hermansson1988}.
%resulting in deviation from the desired microcanonical ensemble.
%
In this study, we will follow a compromised solution,
in which the magnitude of velocity scaling is gradually toned down.
%
In this way,
the temperature controller can
%get close to
zero in on
the proper value of the total energy
early in simulation,
and gradually improve its precision
in later stages.
%while its long time influence is often negligible.


%As a result of the above strategy
Accordingly,
we will propose a modified velocity scaling scheme,
which will be referred to as adaptive velocity scaling below,
aiming for an \emph{asymptotic} microcanonical ensemble,
in which
the total energy gradually tends to the value
corresponding to the target temperature.
%
The effectiveness of this modification,
in terms of the convergence of the total energy,
depends on how
the magnitude of velocity scaling, $\alpha(t)$,
varies with the number of steps, $t$.
%
%Fortunately, we may borrow the optimal scheme $\alpha(t)$
To find the optimal schedule of $\alpha(t)$,
we may recall the $1/t$ prescription\cite{
  belardinelli2007, *belardinelli2007jcp, *belardinelli2008,
  zhou2005, *zhou2008, *morozov2007}
for improving the convergence of
the Wang-Landau (WL) algorithm\cite{
  wang2001, *wang2001pre}.
%
The WL algorithm,
which falls in a larger class of free energy methods
of metadynamics\cite{
  laio2002, laio2008, marsili2006},
has parameters for the entropy that need to be
determined and updated adaptively,
and the $1/t$ prescription gives the optimal updating magnitude
for the parameters to reach their target values.
%
By analogy, we may compare the total energy here
to a parameter in the WL algorithm,
and speculate that the optimal magnitude
of velocity scaling would be
the inverse number of steps.
%inversely proportional to the number of steps.
%
%Such a modification could hopefully gradually decrease
We will show that this is indeed the case:
the $1/t$ modified velocity scaling can reduce
the fluctuation of the total energy
at an optimal rate.
%
%Besides the above change,
%our modification will target a % a more accurate
%microcanonical temperature\cite{rugh1997}
%based on the surface or Boltzmann entropy\cite{
%frenkel2015},
%which turns out to be different
%from the usual definition, Eq. \eqref{eq:K_canon}.
%
As we will see,
the magnitude of velocity scaling
often decreases so rapidly that
a sufficiently long simulation under adaptive velocity scaling
is almost identical to a regular MD
in conserving the total energy and producing other quantities
of the microcanonical ensemble.



\section{Methods}



\subsection{Background in statistical mechanics}



%Our adaptive velocity scaling scheme aims at
%controlling the temperature for an MD simulation.
Our goal is to design a temperature controller for a plain MD simulation.
%
Since MD follows Newton's equation of motion
that conserves the total energy, $E$,
the resulting trajectory can be described in statistical mechanics
by a microcanonical or $NVE$ ensemble,
which is a collection of configurations in the phase space
with the same total energy, $E$.
%
Unlike the more commonly-used canonical or $NVT$ ensemble,
temperature, $T$, is not a parameter of the microcanonical ensemble,
but only an observable
that is influenced by the ensemble parameter, $E$.
%
In other words,
we may write temperature
only as a function of the total energy, $T = T(E)$,
in the microcanonical ensemble.
%
Accordingly, the desired controller must adjust the total energy
to effect temperature changes.


Let us now review the temperature function, $T(E)$,
%relation between temperature, $T$,
%and total energy, $E$,
in the microcanonical ensemble.
%
We will denote a configuration in the trajectory
by a vector $\mathbf x$,
encompassing both the coordinates and momenta.
%
Under the ergodicity hypothesis,
Newton's equation will populate configurations
that spread evenly over
the isoenergetic hypersurface in the phase space,
defined by
$H(\mathbf x) = E$,
where $H(\mathbf x)$ is the Hamiltonian function.
%
Then, thermodynamic properties, such as the entropy and temperature,
of the MD trajectory
can be described by the geometry of the isoenergetic hypersurface.
%
In particular, the hypervolume enclosed by the hypersurface
%
\begin{equation}
  \Phi(E)
  =
  \int
    \Theta\bigl( E - H(\mathbf x) \bigr)
    \, d\mathbf x
  ,
  %\notag
  \label{eq:PhiE}
\end{equation}
%
defines a bulk or volume entropy\cite{
  cagin1988, haile, dunkel2014}
as $S_\Phi = \ln \Phi(E)$,
where $\Theta(y)$ is the step function,
which gives $1.0$ for a positive $y$, or $0.0$ otherwise.
%
The hypervolume is
an adiabatic invariant\cite{
  gibbs, hertz1910a, hertz1910b, munster, becker,
  cagin1988, rugh2001, adib2002, dunkel2014}
in the mechanical sense,
i.e. it would remain a constant
when a system parameter, such as volume,
changes slowly,
and, therefore, its logarithm serves as
a natural definition of the entropy.
%
The derivative of the entropy
%
\begin{equation}
  \frac{1}{ k_B \, T_\Phi(E) }
  =
  \frac{ d }{ dE }
  \ln \Phi(E)
  =
  \frac{ \Phi'(E) }
       { \Phi(E)  }
  .
  \label{eq:betaE_def}
\end{equation}
%
defines the corresponding temperature function, $T_\Phi(E)$,
for the microcanonical ensemble.

Alternatively, the entropy may be defined
as the logarithm of the density of states,
$\Omega(E) \equiv \Phi'(E)$,
%
\begin{equation}
  \Omega(E)
  =
  \int
    \delta\bigl( E - H(\mathbf x) \bigr)
    \, d\mathbf x
  ,
  \label{eq:DOSE}
\end{equation}
%
which gives rise to a surface microcanonical temperature
%
\begin{equation}
  \frac{1}{ k_B \, T_\Omega(E) }
  =
  \frac{ d }{ dE }
  \ln \Omega(E)
  =
  \frac{ \Omega'(E) }
       { \Omega(E)  }
  .
  \label{eq:betaE_surf_def}
\end{equation}



Either temperature definition can be converted to
an average in the microcanonical ensemble,
which is defined for quantity, $A(\mathbf x)$, as
$$
  \langle A \rangle_E
  \equiv
  \frac{ 1 } { \Omega(E) }
  \int A(\mathbf x) \,
    \delta\bigl( E - H(\mathbf x) \bigr) \, d\mathbf x
  .
$$
Under the ergodicity hypothesis,
this ensemble average is equivalent to a trajectory average
which can be readily computed from MD.
%
For example, for the bulk definition, we have
%
\begin{equation}
  k_B \, T_\Phi(E)
  =
  \frac{ 2 \left\langle K \right\rangle_E } { N_f }
  ,
  \label{eq:TE_K}
\end{equation}
%
and for the surface definition,
%
\begin{equation}
  \frac{ 1 } { k_B \, T_\Omega(E) }
  =
  \left\langle
  \frac{ \frac{1}{2} N_f - 1 } { K }
  \right\rangle_E
  .
  \notag
  %\label{eq:betaE_invK}
\end{equation}
%
Since Eq. \eqref{eq:TE_K} is compatible
with the conventional definition,
Eq. \eqref{eq:K_canon},
we will assume the bulk definition
unless specified otherwise,
i.e. $T(E)$ means $T_\Phi(E)$.
%
%


By velocity scaling, we wish to
find a value of the total energy, $E^*$,
at which the microcanonical temperature
matches the target value, $T^*$,
i.e. the solution of
%
\begin{equation}
  T(E^*)
  =
  T^*
  .
  \label{eq:T_star}
\end{equation}
%
For an unknown system,
both the temperature function, $T(E)$,
and the solution of Eq. \eqref{eq:T_star}
must be learned gradually from simulation.
%
To gradually improve
our knowledge of the temperature function,
and hence the estimate of the target energy, $E^*$,
we will resort to the adaptive averaging technique
described below.



\subsection{Adaptive averaging}



Suppose that in each MD step, $t$,
we may form an independent estimate of $E^*$,
$\mathcal E_t$,
then a more reliable estimate of $E^*$
would be the average of
all previous independent estimates,
%
\begin{equation}
  \bar{\mathcal E}_t
  =
  \frac 1 t
  \sum_{\tau = 1}^t
    \mathcal E_\tau
  .
  \label{eq:Epsave}
\end{equation}
%
Naturally, the precision of the runtime average
improves over the simulation course.



Our adaptive velocity scaling
improves over the regular velocity scaling
by using the above runtime average,
$\bar{\mathcal E}_t$,
instead of $\mathcal E_t$
to guide the amount of energy change in each step.
%
That is, we want
the total energy of the system
at the end of each step
to be given by
the runtime average, $\bar{\mathcal E}_t$.
%instead of $\mathcal E_t$.
%
This condition requires the amount of energy increment
by velocity scaling in step $t$ to be
%
\begin{equation}
  \delta E_t
  =
  \bar{\mathcal E}_t - \bar{\mathcal E}_{t - 1}
  .
  \label{eq:dE_adaptive}
\end{equation}

As the runtime average from Eq. \eqref{eq:Epsave}
stabilizes, the magnitude of velocity scaling
naturally decreases.
%
This can be seen by rewriting Eq. \eqref{eq:Epsave}
as a recurrence relation
%
\begin{align}
  \bar{\mathcal E}_t
  &=
  \frac{1}{t}
  \left[
    (t - 1) \, \bar{\mathcal E}_{t - 1}
    + \mathcal E_t
  \right]
  \notag \\
  &=
  \bar{\mathcal E}_{t - 1}
  +
  \frac{
    \mathcal E_t - \bar{\mathcal E}_{t - 1}
  }
  {
    t
  }
  .
\label{eq:Epsave_recur}
\end{align}
%
Here we may understand $\mathcal E_t - \bar{\mathcal E}_{t - 1}$
as the independent correction
to the current average $\bar{\mathcal E}_{t - 1}$
from the configuration at step $t$,
and Eq. \eqref{eq:Epsave_recur} shows that
when the correction is absorbed in the runtime average
it carries the decreasing weight of $1/t$,
as a result of the increasing sample size.
%
From Eqs. \eqref{eq:dE_adaptive} and \eqref{eq:Epsave_recur},
we obtain the optimal amount of energy change
for each MD step
\begin{align}
  \delta E_t
  =
  \frac{ 1 } { t }
  \cdot
  \left( \mathcal E_t - \bar{\mathcal E}_{t - 1} \right)
  .
  \label{eq:dE_opt}
\end{align}
%
This amount of energy change is to be realized by velocity scaling.
%
Equation \eqref{eq:dE_opt} is essentially
an application of
the $1/t$ prescription\cite{
  belardinelli2007, *belardinelli2007jcp, *belardinelli2008,
  zhou2005, *zhou2008, *morozov2007}
for the optimal control of the updating magnitude
of the WL algorithm\cite{wang2001, *wang2001pre},
and the above derivation results from its close connection\cite{
  marsili2006, barducci2008}
to the adaptive biasing force method\cite{darve2001, *darve2008}.
%



\subsection{Linearization}



Next, we need to form an independent estimate of
$\mathcal E_t$ of $E^*$.
%
For this, we will form
an independent estimate of
the instantaneous temperature, $T_t$,
and solve a linearized version of Eq. \eqref{eq:T_star}.

Linearizing Eq. \eqref{eq:T_star} around the solution
yields
%
\begin{equation*}
T^*
\approx
T( E )
+
T'( E^* ) \, ( E^* - E )
,
%\label{eq:T_linear}
\end{equation*}
%
or
%
\begin{equation}
E^*
\approx
E
+
\frac{ T^* - T(E) }
     { T'(E^*) }
.
\label{eq:E_inversion}
\end{equation}
%
In adaptive velocity scaling,
we require the total energy at the beginning of every step
(before scaling) to match the previous runtime average,
$\bar{\mathcal E}_{t - 1}$.
%
Thus, if we use $\bar{\mathcal E}_{t - 1}$ for $E$
and $T_t$ for $T(E)$
in Eq. \eqref{eq:E_inversion},
$E^*$ would be the independent estimate
$\mathcal E_{t}$ at step $t$:
%
%
\begin{equation}
\mathcal E_t
=
\bar{\mathcal E}_{t - 1}
+
\frac{ T^* - T_t }
     { T'(E^*) }
.
\label{eq:Eps}
\end{equation}
%
Thus, the optimal energy increment,
from Eqs. \eqref{eq:dE_opt} and \eqref{eq:Eps},
is
%
\begin{equation}
\delta E_t
=
\frac{ 1 } { t }
\cdot
\frac{ T^* - T_t }
     { T'(E^*) }
.
\label{eq:dE_T}
\end{equation}
%



\subsection{Microcanonical temperature}


We now give formulas for $T_t$
and $T'(E)$ required in Eq. \eqref{eq:dE_T}.
%
%It can be shown that both the microcanonical temperature, $T(E)$,
%and $T'(E)$ can be evaluated as
%averages in the microcanonical ensemble\cite{cagin1988, rugh1997}:
%
For the instantaneous temperature, $T_t$,
we can use the quantity under average in Eq. \eqref{eq:TE_K},
or $2 \, K_t/(k_B \, N_f)$,
where
$K_t$ is the kinetic energy before velocity scaling at step $t$.
%
Thus, the optimal energy increment is given by
Eq. \eqref{eq:dE_T}:
%
\begin{equation}
\delta E_t
=
\frac{ 1 } { t } \cdot
\frac{ 1 } { k_B \, T'(E^*) }
\left(
 k_B \, T^*
 -
 \frac{ 2 \, K_t } { N_f }
\right)
,
\label{eq:dE_final}
\end{equation}
%
where the derivative, $T'(E)$
can be computed as\cite{cagin1988}
%
\begin{align}
  k_B \, T'(E^*)
  %&=
  %1
  %-
  %T(E) \, \beta_\Omega(E)
  %\notag
  %\\
  &=
  1
  -
  \left(
    1 - \frac{2}{N_f}
  \right)
  \left\langle
  K
  \right\rangle_E
  \left\langle
    \frac 1 K
  \right\rangle_E
  %\\
  %&=
  %k_B \, T(E) \,
  %\left\langle K^{-1} \right\rangle_E
  %-
  %\left\langle
  %  \Delta K
  %  \Delta \left( K^{-1} \right)
  %\right\rangle
  \notag
  %\label{eq:dTdE}
  \\
  &\approx
  1
  -
  \left(
    1 - \frac{ 2 } { N_f }
  \right)
  \overline{ K }
  \,
  \overline{ \left( \frac 1 K \right) }
  .
  \label{eq:dT}
\end{align}
%
Here,
$\overline A$ means the trajectory average of $A$.
%and
%$\operatorname{Var}(A) = \overline{ A^2 } - {\overline A}^2$
%is the corresponding variance.

In practice, velocity scaling is often implemented
only every $m$ MD steps.
%
In this case,
we can replace the number of MD steps, $t$,
in Eq. \eqref{eq:dE_final} by
the number of velocity-scaling operations
(i.e. $t \to t/m$).
%
The $K_t$ in the formula can be interpreted as
the kinetic energy right before scaling
or the average of values in the past $m$ steps
[see Appendix \ref{sec:block}].




\subsection{\label{sec:gamma}
Approximations on $T'(E^*)$}


Ideally, we should have $T'(E) \ge 0$
as the temperature $T$ increases the total energy $E$.
%
This, however, may not be true in practice
because of numerical error.
%
%Further, since the variance is nonnegative, we have
%%
%\begin{equation*}
%  - \overline{
%    \left(
%      \frac{ N_f - 2 }
%           { 2 \, K_t^2 }
%    \right)
%    }
%  \le
%  \beta'(E^*)
%  \le
%  0,
%\end{equation*}
%
To avoid the variance term,
we may define a ratio
%
\begin{equation}
  \gamma
  \equiv
  \frac
  {
    d \langle K \rangle_E
  }
  {
    dE
  }
  ,
  %\notag
  \label{eq:gamma_def}
\end{equation}
%
such that
%
\begin{equation}
  k_B \, T'(E^*)
  =
  \frac{ 2 \, \gamma } { N_f }
  .
  \notag
  %\label{eq:dT_approx}
\end{equation}
%
For a physical system, we expect $0 \le \gamma \le 1$.
%
%The value of $\gamma$ is computed for a model system
%in Appendix \ref{sec:model}.

With the above definition, we can rewrite Eq. \eqref{eq:dE_final} as
%
\begin{equation}
  \delta E_t
  =
  \frac{ K^* - K_t } { \gamma \, t }
  .
  \notag
  %\label{eq:dE_gamma}
\end{equation}
%
Comparing this to Eq. \eqref{eq:Berendsen},
we find the adaptive velocity scaling scheme
can be considered as a modification of the Berendsen thermostat
with the damping factor $\tau$ being $\gamma \, t$,
which increases as simulation progresses.


We can use the ratio in two ways.
%
First, we may propose a minimal value of $\gamma$, say $0.1$,
to prevent an overly small value from Eq. \eqref{eq:dT}.

Second,
we can determine an approximate heuristic value of $\gamma$
that is applicable for a class of similar systems.
%
For example,
for an explicit solvent simulation of TIP3P water\cite{jorgensen1983}
at 300K, we find that the optimal $\gamma$
to be around $0.33$.


\subsection{Generalization}


The adaptive velocity scaling scheme
is a special application of the $1/t$ prescription
in which we adjust the total energy
to achieve the target temperature.
%
More generally, we may apply this technique
to a pair of strongly correlated variables $x$ and $y$,
to find the optimal value of a parameter, $x$,
that corresponds to a target value, $y^*$, of an observable, $y$.
%on the fly.
%
Then, the change of $x$ in each step is given by
\begin{equation}
  \delta x_t = \frac 1 t
  \cdot
  \frac{ y^* - y_t }
       { y'(x^*) }
  .
  \label{eq:adjustxy}
\end{equation}
%
For example, we may determine the value of volume in the $NVT$ ensemble
that corresponds to a certain value of pressure.
%
%For example, one may determine the optimal
Another example is the determination of the
move size ($x$)
in a Monte Carlo simulation
in order to reaching a certain acceptance ratio ($y$).




\section{Results}



We coded the adaptive velocity scaling scheme to
the MD program NAMD\cite{NAMD},
and tested it on a box of water.
%
The system contains
$798$ TIP3P water molecules\cite{jorgensen1983}
in a cubic box of $30 \, \mathrm{\AA}$ side length.
%
Velocity scaling was conducted every $10$ steps
unless specified otherwise.
%
The MD time step was $2$ femtoseconds;
the temperature was $300$ K.
%
We used the particle-meshed Ewald method\cite{essmann1995}
with a spacing of $1 \, \mathrm{\AA}$
to compute the electrostatic interaction,
and the SETTLE method\cite{miyamoto1992}
to maintain the constraints.


We first compared the fluctuation of the total energy
from three simulations:
%
a regular MD without velocity scaling,
one under the regular velocity scaling scheme as described in the Introduction,
and one under adaptive velocity scaling.
%
Note that although Newton's equation conserves the total energy,
MD simulations usually employ approximate integration schemes
(such as the velocity Verlet),
with
small fluctuation of the total energy.
%
In all three cases,
we set the initial total energy to the correct value, $-6141.2$ kcal/mol.
%
In the second case,
velocity was scaled every $100$ or $1000$ MD steps.
%
In the last case,
velocity was scaled every $10$ MD steps with
$T'(E^*)$ computed from Eq. \eqref{eq:dT}.
%
As shown in Table \ref{tab:etraj},
the energy fluctuation from the simulation under adaptive velocity scaling
was similar to that from a regular MD,
which suggests that the influence of adaptive velocity scaling
becomes negligible for long simulations.
%
However, regular velocity scaling
produced much larger energy fluctuations
that increases with the scaling frequency.

\begin{table}[h]
  \setlength{\tabcolsep}{5pt}
  \renewcommand{\arraystretch}{1.5}
  \begin{center}
    \begin{tabular}{ p{2.5cm} | c p{1.3cm} p{1.3cm} c }
      \hline
      Velocity scaling
      &   None    &   Regular \newline $\nu =100 $   & Regular \newline $\nu = 1000$  &   Adaptive \\
      \hline
      $\sigma_E$ (kcal/mol)
      &   $0.26$  &   $20$    &  $7.7$     &   $0.25$ \\
      \hline
    \end{tabular}
  \end{center}
  \caption{
    \label{tab:etraj}
    Standard deviations of the total energy, $\sigma_E$,
    from simulations under different types of velocity scaling.
    %
    Each simulation lasted $10^7$ steps,
    and the standard deviation of the total energy,
    excluding the first $10^6$ steps, was reported.
    %
    The frequency of regular velocity scaling
    is denoted by $\nu$.
    %
    \note{
      The raw data were saved in
      \texttt{data/wb/fix/ene0fix.log},
      \texttt{data/wb/reg100/ene0reg.log},
      \texttt{data/wb/reg/ene0reg.log},
      and
      \texttt{data/wb/adp/ene0adp.log}.
      The standard deviations can be found with
      \texttt{make etraj -C data/wb}.
    }%
  }
\end{table}

%\begin{figure}[h]
%\begin{center}
%  \makebox[\linewidth][c]{
%    \includegraphics[angle=0, width=1.0\linewidth]{fig/etraj.pdf}
%  }
%  \caption{
%    \label{fig:etraj}
%    The time series of the total energy
%    from an MD trajectory
%    without velocity scaling (with the total energy $E \approx -6141.5$),
%    one under regular velocity scaling
%    (conducted every $10^3$ steps),
%    %(in which the velocity is scaled
%    %every $m = 10^4$ steps by a factor of
%    %$\sqrt{\frac12 N_f k_B T/\bar K}$,
%    %with $\bar K$ being the average kinetic energy
%    %of the past $m$ steps),
%    and
%    one under adaptive velocity scaling (conducted every $10$ steps).
%    %
%    Each simulation lasted $10^7$ steps,
%    but only the data from the first $3\times 10^6$ steps were shown.
%    %
%    %The points were plotted every $5 \times 10^4$ steps.
%    %
%    The standard deviations of the total energy,
%    excluding the first $10^6$ steps,
%    were $0.26$, $7.7$, and $0.25$ $\mathrm{kcal/mol}$,
%    respectively.
%    %
%    \note{The figure was produced by \texttt{doc/fig/etraj.gp}.
%      The raw data were saved in
%      \texttt{data/wb/fix/ene0fix.log},
%      \texttt{data/wb/reg/ene0reg.log},
%      and
%      \texttt{data/wb/adp/ene0adp.log}.
%      The standard deviations can be found with
%      \texttt{make etraj -C data/wb}.
%    }%
%  }
%\end{center}
%\end{figure}



We then compared the kinetic and potential energy
distributions from a regular MD simulation,
a simulation under adaptive velocity scaling,
a simulation under regular velocity scaling (performed every $100$ steps),
and
a simulation under the velocity rescaling
thermostat\cite{bussi2007}
(with $\tau = 0.03 \, \mathrm{ps}$).
%
The former two targets an (asymptotic) microcanonical ensemble,
whereas the last targets a canonical ensemble.
%
As shown in Fig. \ref{fig:kuhist},
adaptive velocity scaling and regular MD
produced almost identical distributions for the microcanonical ensemble,
while the simulation under the velocity rescaling thermostat
produced wider distributions for the canonical ensemble.
%
We may understand the widening % of the distributions
as a result of the construction of the canonical ensemble
as a superposition of microcanonical ensembles of different $E$'s.
%
Regular velocity scaling, however, produced
a potential energy distribution that
was visibly different from
those in the microcanonical and canonical ensembles.
%
%More interestingly,
%Fig. 2 shows that the adaptive velocity scaling
%yields shorter correlation for the kinetic energy.

\begin{figure}[h]
\begin{center}
  \makebox[\linewidth][c]{
    \includegraphics[angle=0, width=1.0\linewidth]{fig/kuhist.pdf}
  }
  \caption{
    \label{fig:kuhist}
    Kinetic and potential energy distributions
    from a regular MD simulation in the microcanonical ensemble,
    a simulation under adaptive velocity scaling,
    one under regular velocity scaling,
    and one in the canonical ensemble.
    %
    %Each simulation had $10^7$ steps,
    %and the data from the first $10^6$ steps
    %were dropped.
    %
    \note{The figure was produced by \texttt{doc/fig/kuhist.gp}.
      For data preparation, \texttt{make uhist khist -C data/wb}.
    }%
  }
\end{center}
\end{figure}


Next, we wish to see if Eq. \eqref{eq:dE_final}
is indeed optimal in controlling the magnitude of velocity scaling.
%
To this end, we modified the energy change in
the adaptive velocity scaling scheme as
%such that the energy change in each step is given by
%
\begin{equation}
  \delta E_t
  =
  \frac{ \alpha(t) } { k_B \, T'(E^*) }
  \left(
   k_B \, T^* -
   \frac{ 2 \, K_t } { N_f }
  \right)
  ,
  \label{eq:dE_mod}
\end{equation}
%
where $\alpha(t) = z/t$ with $z$ being a free parameter;
and Eq. \eqref{eq:dE_final} is the $z = 1$ case.
%
For each value of $z$,
we performed multiple independent simulations of
$T = 10^5$ and $10^6$ steps,
and used the variance of the total energy at the simulation end
to represent the error.
%
For $\beta'(E^*)$,
Eq. \eqref{eq:dbeta_approx2} was used with the heuristic value of
$\gamma = 0.33$,
which was obtained from Eq. \eqref{eq:gamma_def}
using the data of the first test.
%
As shown in Fig. \ref{fig:errz},
the value of $z = 1$
indeed gives the least error,
supporting the optimality of Eq. \eqref{eq:dE_final}.

\begin{figure}[h]
\begin{center}
  \makebox[\linewidth][c]{
    \includegraphics[angle=0, width=1.0\linewidth]{fig/errz.pdf}
  }
  \caption{
    \label{fig:errz}
    Error of the total energy,
    measured as the fluctuation
    $\left\langle \Delta E^2(T) \right\rangle$,
    at the end of a simulation of $T$ steps,
    versus the variable $z$
    in the modified velocity scaling scheme,
    Eq. \eqref{eq:dE_mod}.
    %
    The points are results from averaging over
    multiple independent runs.
    %
    The curves are the analytical predictions from
    Eq. \eqref{eq:err_functional},
    for which we have computed the autocorrelation function
    of the fluctuation
    $\xi(t) = \left[T^* - \left( 2 K_t / N_f \right)\right]/\left[ k_B T'(E^*) \right]$
    from a regular MD simulation.
    %
    %The thinner curves were from a more approximate formula,
    %Eq. \eqref{eq:err_zovert},
    %which assumes the fluctuation is a white noise
    %%and this assumption is less reliable for shorter simulations
    %(cf. Appendix \ref{sec:error}).
    %
    \note{The figure was produced by \texttt{doc/fig/errz.gp}.
      The raw data were saved in \texttt{data/wb\_t100000.dat}.
      For the analytical prediction \texttt{make -C data/wb wberrz}.
    }%
  }
\end{center}
\end{figure}



Finally, we wish to test
the efficiency of the adaptive velocity scaling scheme
in recovering from a bad initial condition.
%
To this end,
we compared this scheme,
which targets the microcanonical ensemble,
with several temperature control schemes
targeting the canonical ensemble.
%
In this test, we initially lifted the total energy about
$100\,\mathrm{kcal/mol}$ above the average,
and monitored the evolution of the total energy.
%
As shown in Fig. \ref{fig:equil},
adaptive velocity scaling
behaved similarly to
the Nos\'e-Hoover chain\cite{nose1984, nose1984mp, hoover1985, martyna1992},
and velocity rescaling\cite{bussi2007}
thermostats
in the relaxation process;
and the velocity-scaling-based schemes
appeared to be more efficient than Langevin dynamics.
%
Note that the relaxation
of the thermostat algorithms
depends on some input parameters
(e.g., the inverse viscosity $\tau$ of the velocity rescaling thermostat),
whereas adaptive velocity scaling does not.

\note{
We also note that relaxation curve of the thermostat algorithms
take an exponential form ($\propto e^{-k\,t}$),
while that of adaptive velocity scaling takes
an algebraic form [$\propto 1/t$,
cf. \eqref{eq:abserr}].
%
One may wonder if it is more effective to use an exponential form
for the magnitude of velocity scaling,
$\alpha(t) \propto e^{-kt}$.
%
This is no so, as the alternative functional forms
would be less effective in the long run
in eliminating the cumulative random error
caused by velocity scaling itself,
i.e. the error bar of Fig. \ref{fig:equil} (not shown).
%
For the canonical ensemble, the fluctuation is unimportant
as the total energy is intrinsically fluctuating.
%
However, for the microcanonical ensemble, the fluctuation
is the key measure of convergence.
%
This is why adaptive velocity scaling chooses the $1/t$ form
instead of the exponential form for the scaling magnitude.
}

\begin{figure}[h]
\begin{center}
  \makebox[\linewidth][c]{
    \includegraphics[angle=0, width=1.0\linewidth]{fig/equil.pdf}
  }
  \caption{
    \label{fig:equil}
    Time series of the total energy
    of simulations under
    adaptive velocity scaling,
    Langevin dynamics,
    Nos\'e-Hoover chain thermostat
    and
    velocity rescaling thermostat.
    %
    For Langevin dynamics,
    the damping parameter was $1.0 \, \mathrm{ps}^{-1}$.
    %
    For the Nos\'e-Hoover chain thermostat,
    we used $5$ chain variables. The masses
    of the first and the rest variables
    were $N_f \, \omega^2 \, k_B T$ and
    $\omega^2 \, k_B T$, respectively\cite{martyna1992},
    and
    $\omega = 2 \,\pi/(0.1 \, \mathrm{ps})$.
    %
    For the velocity rescaling thermostat,
    we tried two values of the inverse viscosity $\tau$,
    $0.1 \, \mathrm{ps}$ and $0.03 \, \mathrm{ps}$.
    %
    The average kinetic energy of the system
    was roughly $1426 \, \mathrm{kcal/mol}$.
    %
    The results were averaged over $10^4$ independent trials.
    %
    %\red{The lines are a guide to the eyes.}
    %
    \note{The figure was produced by \texttt{doc/fig/equil.gp}.
    }%
  }
\end{center}
\end{figure}






\section{\label{sec:conclusion}
Conclusions and Discussions}



In summary, we have presented an adaptive velocity scaling scheme
as a more precise temperature control for the microcanonical ($NVE$) ensemble.
%
Unlike the canonical ($NVT$) ensemble,
the microcanonical ensemble requires a constant total energy, $E$,
which is incompatible with the usual periodic velocity scaling scheme
with a fixed magnitude.
%
Our modified scheme gradually decreases the magnitude of the velocity scaling
by a factor of the number of steps.
%
Like the $1/t$ prescription\cite{
  belardinelli2007, *belardinelli2007jcp, *belardinelli2008,
  zhou2005, *zhou2008, *morozov2007}
for the WL algorithm\cite{wang2001, *wang2001pre},
the adaptive velocity scaling is able to reach
the desired temperature at an optimal rate.
%
Because of the magnitude control,
the effect of velocity scaling often becomes negligible
at long times so that
a simulation under adaptive velocity scaling
behaves similarly to a regular MD simulation.

We may view the adaptive velocity scaling scheme
as an application of the $1/t$ prescription
for adjusting the total energy
to achieve the target temperature.
%
More generally, we may apply this technique
to a pair of strongly correlated variables $x$ and $y$,
to find the optimal value of a parameter, $x$,
that corresponds to a target value of $y^*$.
%on the fly.
%
We expect this and similar parameter control schemes
to be useful in molecular simulations.




\section{Acknowledgment}

We thank Dr. J. Ma, Dr. M. W. Deem, Dr. Y. Mei,
O. Nassar, Dr. C. Lai, Dr. S. Ou and D. Stuhlsatz
for helpful discussions.
We gratefully acknowledge the Robert A. Welch Foundation (H-0037),
the National Science Foundation (CHE-1152876)
and
the National Institutes of Health (GM-037657) for partial support of this work.
%
%This research used computing resources of the National Science Foundation XSEDE grid.
We also acknowledge the Texas Advanced Computing Center (TACC) at The University of Texas
at Austin for providing HPC and storage resources that have contributed to
the research results reported within this paper.

\appendix






\section{\label{sec:Tsurf}
Modification for the surface temperature}



The adaptive velocity rescaling in the main text
targets the bulk temperature.
%
Below we list a few changes that need to be made
for targeting the alternative surface definition.

According to the definition from
Eqs. \eqref{eq:DOSE} and \eqref{eq:betaE_surf_def},
we have
\begin{align}
  \beta_\Omega(E)
  &=
  \left\langle
    \frac{ \frac{1}{2}N_f - 1 } { K }
  \right\rangle
  ,
  \notag
  %\label{eq:betaE_invK}
  \\
  \beta'_\Omega(E)
  &=
  -
  \left\langle
    \frac{ \frac{1}{2} N_f - 1 } { K^2 }
  \right\rangle
  +
  \left\langle
    \Delta
    \left(
      \frac{ \frac{1}{2} N_f - 1 } { K }
    \right)^2
  \right\rangle
  ,
  \notag
\end{align}

The energy change in each velocity scaling step is given by
\begin{equation}
  \delta E_t
  =
  \frac{1}{t} \cdot
  \frac{ \beta^* - (\frac{1}{2} N_f - 1)/K_t }
  { \beta'_\Omega(E) }
  .
\end{equation}




\section{\label{sec:block}
Block average}

\newcommand{\tmax}{\mathcal T}

If block average is used, we have
%
\begin{align*}
  \sum_{t = 1}^{\tmax} \frac{ A_t } { t }
  &=
  \sum_{\tau = 1}^{\tmax/m}
  \sum_{\tau' = 1}^{m}
  \frac{ A_t } { (\tau - 1) \, m + \tau' }
  \\
  &\approx
  \sum_{\tau = 1}^{\tmax/m}
  \frac{ 1 } { \tau }
  \left(
    \frac 1 m
    \sum_{\tau' = 1}^m
    A_t
  \right)
  =
  \sum_{\tau = 1}^{\tmax/m}
  \frac{ A^*_\tau } { \tau }
  .
\end{align*}
%
where
$t = (\tau - 1) \, m + \tau'$
and
$
A_{\tau*} = \frac 1 m
\sum_{\tau' = 1}^m A_t.
$

In our case,
$
A_t = k_B T^* - \left( 2 K_t / N_f\right),
$
and the block average is
$
A_{\tau*}
= k_B T^* - \left( 2 K_{t*} / N_f\right),
$
where $K_{\tau*}$
is the block average of $K_t$.

%\bibliographystyle{abbrv}
\bibliography{simul}
\end{document}
